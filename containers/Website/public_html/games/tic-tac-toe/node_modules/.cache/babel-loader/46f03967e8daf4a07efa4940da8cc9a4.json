{"ast":null,"code":"import openSocket from 'socket.io-client'; //Connection Status (this.state.status)\n// -3 => unauthorized user\n// -2 => trying to reconnect\n// -1 => no connection (the client has not connect to the giver Playmaster)\n//  0 => connected\n//  1 => wait opponent to connect\n//  2 => ready to play\n//  3 => the game is completed\n//  4 => winner because opponent left\n//Instructions\n//Get argument from the URL\n\nexport function getArgumenets() {\n  let url_string = window.location['href'];\n  let url = new URL(url_string);\n  let host = url.hostname;\n  let playmanster = url.searchParams.get(\"pm\");\n  let gamemaster = url.searchParams.get(\"gm\");\n  let token = url.searchParams.get(\"token\");\n  let args = {\n    'host': host,\n    'token': token,\n    'playmanster': playmanster,\n    'gamemaster': gamemaster\n  };\n  return args;\n} //Connect to Playmaster\n\nexport function connect(server, token) {\n  let handShake = {\n    query: 'token=' + token\n  };\n  let socket = openSocket(server, handShake);\n  console.log(socket);\n  let response = {\n    'socket': socket,\n    'status': socket['connected'] ? 0 : -1\n  };\n  return response;\n}\nexport function setListeners(obj) {\n  //You connected first, wait for the opponent to connect\n  obj.state.socket.on('wait', message => {\n    obj.setState({\n      status: 1,\n      roundID: message['roundID']\n    });\n  }); //Both players are connected. The game can begin\n\n  obj.state.socket.on('init', message => {\n    //Check if the game is new or it is continued from server fault.\n    if (obj.state.type === null) {\n      let turn = message['turn'];\n      let type = turn ? 'X' : 'O';\n      obj.setState({\n        status: 2,\n        type: type,\n        myTurn: turn,\n        roundID: message['roundID']\n      });\n    } else {\n      obj.setState({\n        status: 2,\n        roundID: message['roundID'] //get the new round ID\n\n      });\n    }\n  }); //Receive the updated board\n\n  obj.state.socket.on('board', board => {\n    obj.setState({\n      squares: board,\n      myTurn: true\n    });\n  }); //Handler for server disconnection\n\n  obj.state.socket.on('disconnect', board => {\n    //if you never connected or the game is completed, return\n    if (obj.state.status < 0 || obj.state.status > 2) {\n      return;\n    }\n\n    obj.state.socket.disconnect();\n    obj.setState({\n      status: 4\n    }); //Create a request to GameMaster\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.onload = function (e) {\n      if (xhr.readyState === 4) {\n        //Check if the GameMaster accepted the request\n        if (xhr.status === 200) {\n          let respone = JSON.parse(xhr.responseText);\n          obj.reconnect(respone['playmaster']);\n        } else if (xhr.status === 403) {\n          obj.setState({\n            status: -3\n          });\n        }\n      }\n    };\n\n    let game = 'tic-tac-toe';\n    let master = obj.state.host + ':' + obj.state.gamemaster;\n    let url = 'http://' + master + '?' + 'token=' + obj.state.token + '&game=' + game;\n    xhr.open('GET', url);\n    xhr.send();\n  }); //The game is over from the server's side\n\n  obj.state.socket.on('endgame', message => {\n    obj.setState({\n      status: 4\n    });\n    obj.state.socket.disconnect();\n  });\n} //Establish a new connections\n\nexport function reconnect(obj, port) {\n  console.log('reconnecting...');\n  let playmaster = this.state.host + ':' + port;\n  let token = this.state.token;\n  var data = connect(playmaster, token);\n  obj.setState({\n    socket: data['socket'],\n    status: data['status']\n  });\n  console.log(data['socket']);\n  obj.setListeners();\n}","map":{"version":3,"sources":["/home/panagiotis/Desktop/ds_project/games/tic-tac-toe/src/utils/multiplayer.js"],"names":["openSocket","getArgumenets","url_string","window","location","url","URL","host","hostname","playmanster","searchParams","get","gamemaster","token","args","connect","server","handShake","query","socket","console","log","response","setListeners","obj","state","on","message","setState","status","roundID","type","turn","myTurn","board","squares","disconnect","xhr","XMLHttpRequest","onload","e","readyState","respone","JSON","parse","responseText","reconnect","game","master","open","send","port","playmaster","data"],"mappings":"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","sourcesContent":["import openSocket from 'socket.io-client';\n\n//Connection Status (this.state.status)\n  // -3 => unauthorized user\n  // -2 => trying to reconnect\n  // -1 => no connection (the client has not connect to the giver Playmaster)\n  //  0 => connected\n  //  1 => wait opponent to connect\n  //  2 => ready to play\n  //  3 => the game is completed\n  //  4 => winner because opponent left\n\n//Instructions\n\n\n\n\n//Get argument from the URL\nexport function getArgumenets() {\n\tlet url_string = window.location['href'];\n  \tlet url = new URL(url_string);\n\n  \tlet host = url.hostname;\n  \tlet playmanster = url.searchParams.get(\"pm\");\n  \tlet gamemaster = url.searchParams.get(\"gm\");\n  \tlet token = url.searchParams.get(\"token\");\n\n  \tlet args = {\n  \t\t'host': host,\n  \t\t'token': token,\n  \t\t'playmanster' : playmanster,\n  \t\t'gamemaster' : gamemaster \n  \t};\n\n  \treturn args;\n}\n\n\n//Connect to Playmaster\nexport function connect(server, token){\n\n    let handShake = {\n    \tquery:'token='+token\n    }\n\n    let socket = openSocket(server, handShake)\n\n    console.log(socket)\n\n    let response = {\n    \t'socket': socket,\n    \t'status': socket['connected'] ? 0 : -1,\n    }\n\n    return response;\n}\n\n\nexport function setListeners(obj){\n\n  //You connected first, wait for the opponent to connect\n  obj.state.socket.on('wait', message => {\n    obj.setState({\n        status: 1,\n        roundID: message['roundID'],\n      })\n  });\n\n\n\n  //Both players are connected. The game can begin\n  obj.state.socket.on('init', message => {\n\n    //Check if the game is new or it is continued from server fault.\n    if (obj.state.type === null){\n      let turn = message['turn'];\n      let type = turn ? 'X' : 'O' \n\n        obj.setState({\n          status: 2,\n          type: type,\n          myTurn: turn,\n          roundID: message['roundID']\n        })\n      }else{ \n        obj.setState({\n          status: 2,\n          roundID: message['roundID']   //get the new round ID\n        })\n      }\n  });\n\n\n  //Receive the updated board\n  obj.state.socket.on('board', board => {\n      obj.setState({\n        squares: board,\n        myTurn: true,\n      })\n  }); \n\n\n  //Handler for server disconnection\n  obj.state.socket.on('disconnect', board => {\n\n      //if you never connected or the game is completed, return\n      if (obj.state.status < 0 || obj.state.status > 2) {\n        return;\n      }\n\n    obj.state.socket.disconnect()\n\n    obj.setState({\n      status: 4,\n    })\n    \n    //Create a request to GameMaster\n    var xhr = new XMLHttpRequest()\n\n    xhr.onload = function (e) {\n\n      if (xhr.readyState === 4) {\n\n        //Check if the GameMaster accepted the request\n        if (xhr.status === 200) {  \n          let respone = JSON.parse(xhr.responseText);\n          obj.reconnect(respone['playmaster']);\n        }else if(xhr.status === 403){\n          obj.setState({\n            status: -3,\n          })\n        }\n      }\n    }\n\n    let game = 'tic-tac-toe';\n    let master = obj.state.host + ':' + obj.state.gamemaster\n    let url = 'http://'+master+'?'+'token='+obj.state.token+'&game='+game;\n\n    xhr.open('GET', url);\n    xhr.send();\n  }); \n\n  //The game is over from the server's side\n  obj.state.socket.on('endgame', message => {\n      obj.setState({\n        status: 4,\n      })\n      obj.state.socket.disconnect();\n  }); \n\n}\n\n//Establish a new connections\nexport function reconnect(obj, port){\n  console.log('reconnecting...')\n  let playmaster = this.state.host + ':' + port;\n  let token = this.state.token;\n  var data = connect(playmaster,token)\n\n  obj.setState({\n    socket: data['socket'],\n    status: data['status'],\n  });\n\n  console.log(data['socket']);\n  obj.setListeners();\n}\n\n"]},"metadata":{},"sourceType":"module"}