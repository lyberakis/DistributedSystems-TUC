{"ast":null,"code":"import openSocket from 'socket.io-client';\nimport Bishop from '../pieces/bishop.js';\nimport Knight from '../pieces/knight.js';\nimport Queen from '../pieces/queen.js';\nimport Rook from '../pieces/rook.js';\nimport King from '../pieces/king.js';\nimport Pawn from '../pieces/pawn.js'; // ==========================================\n// ==> Variables in state <==\n//==> host: The domain of the host (localhost)\n//==> gamemaster: the port of gamemaster for client requests\n//==> token: the unique token of the user issued from the Authorization Service\n//==> socket: the socket objet of the client connected to the server\n//==> type: the symbol of the user (X,O or white, black)\n//==> roundID: the ID of the game\n//==> connectionStatus: Connection Status\n// -3 => unauthorized user\n// -2 => trying to reconnect\n// -1 => no connection (the client has not connect to the giver Playmaster)\n//  0 => connected\n//  1 => wait opponent to connect\n//  2 => ready to play\n//  3 => the game is completed\n//  4 => winner because opponent left\n//  5 => spectator mode\n// ==========================================\n// ==> Messages from client to playmaster <==\n// 1. Send the new board \n// let message = {\n//   roundID : this.state.roundID,\n//   board : squares\n// }\n// this.state.socket.emit('update', message)\n// 2. Inform the playmaster for the winner, if you are the last to play\n// let message = {\n//   roundID : this.state.roundID,\n//   winner: winnerInfo,  //0 for tie, 1 if you won, -1 if you lost\n// }\n// this.state.socket.emit('endgame', message)\n// ==========================================\n// ===> FOR OTHER GAME CHANGE THE LINE 109 and 133-140\n// ==========================================\n//Get argument from the URL\n\nexport function getArgumenets() {\n  let url_string = window.location['href'];\n  let url = new URL(url_string);\n  let host = url.hostname;\n  let playmanster = url.searchParams.get(\"pm\");\n  let gamemaster = url.searchParams.get(\"gm\");\n  let token = url.searchParams.get(\"token\");\n  let args = {\n    'host': host,\n    'token': token,\n    'playmanster': playmanster,\n    'gamemaster': gamemaster\n  };\n  return args;\n} //Connect to Playmaster\n\nexport function connect(server, token) {\n  let handShake = {\n    query: 'token=' + token\n  };\n  let socket = openSocket(server, handShake);\n  let response = {\n    'socket': socket,\n    'connectionStatus': socket['connected'] ? 0 : -1\n  };\n  return response;\n}\nexport function setListeners(obj) {\n  //You connected first, wait for the opponent to connect\n  obj.state.socket.on('wait', message => {\n    obj.setState({\n      connectionStatus: 1,\n      roundID: message['roundID']\n    });\n  }); //Both players are connected. The game can begin\n\n  obj.state.socket.on('init', message => {\n    //Check if the game is new or it is continued from server fault.\n    if (obj.state.type === null) {\n      obj.setState({\n        connectionStatus: 2,\n        myTurn: message['turn'],\n        roundID: message['roundID'],\n        myColor: message['turn'] ? 'while' : 'black' //set your color\n\n      });\n    } else {\n      obj.setState({\n        connectionStatus: 2,\n        roundID: message['roundID'] //get the new round ID\n\n      });\n    }\n  }); //Both players are connected. The game can begin\n\n  obj.state.socket.on('viewer', board => {\n    console.log('VIWER');\n    var classes = stringsToClasses(board);\n    obj.setState({\n      connectionStatus: 5,\n      squares: classes,\n      myTurn: false\n    });\n  }); //Receive the updated board\n\n  obj.state.socket.on('board', board => {\n    var classes = stringsToClasses(board[\"board\"]);\n    var whiteFallenSoldiers = stringsToClasses(board[\"whiteFallenSoldiers\"]);\n    var blackFallenSoldiers = stringsToClasses(board[\"blackFallenSoldiers\"]);\n    var turn, player;\n\n    if (!board['dontChange']) {\n      turn = obj.state.turn === 'white' ? 'black' : 'white';\n      player = obj.state.player === 1 ? 2 : 1;\n    } else {\n      turn = obj.state.turn;\n      player = obj.state.player;\n    }\n\n    obj.setState({\n      squares: classes,\n      turn: turn,\n      whiteFallenSoldiers: whiteFallenSoldiers,\n      blackFallenSoldiers: blackFallenSoldiers,\n      status: board['status'],\n      kingStatus: board['kingStatus'],\n      player: player,\n      myTurn: true\n    }); //Set Game progress\n\n    if (board['progress'] !== 0) {\n      obj.setState({\n        connectionStatus: 3\n      });\n    }\n  }); //Handler for server disconnection\n\n  obj.state.socket.on('disconnect', board => {\n    //if you never connected or the game is completed, return\n    if (obj.state.connectionStatus < 0 || obj.state.connectionStatus > 2) {\n      return;\n    }\n\n    obj.state.socket.disconnect();\n    obj.setState({\n      connectionStatus: 4\n    }); //Create a request to GameMaster\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.onload = function (e) {\n      if (xhr.readyState === 4) {\n        //Check if the GameMaster accepted the request\n        if (xhr.connectionStatus === 200) {\n          let respone = JSON.parse(xhr.responseText);\n          obj.reconnect(respone['playmaster']);\n        } else if (xhr.connectionStatus === 403) {\n          obj.setState({\n            connectionStatus: -3\n          });\n        }\n      }\n    };\n\n    let game = 'chess';\n    let master = obj.state.host + ':' + obj.state.gamemaster;\n    let url = 'http://' + master + '?' + 'token=' + obj.state.token + '&game=' + game;\n    xhr.open('GET', url);\n    xhr.send();\n  }); //The game is over from the server's side\n\n  obj.state.socket.on('endgame', message => {\n    obj.setState({\n      connectionStatus: 4\n    });\n    obj.state.socket.disconnect();\n  });\n} //Establish a new connections\n\nexport function reconnect(obj, port) {\n  console.log('reconnecting...');\n  let playmaster = this.state.host + ':' + port;\n  let token = this.state.token;\n  var data = connect(playmaster, token);\n  obj.setState({\n    socket: data['socket'],\n    connectionStatus: data['connectionStatus']\n  });\n  console.log(data['socket']);\n  obj.setListeners();\n}\n\nfunction stringsToClasses(squares) {\n  var classes = [];\n\n  if (squares) {\n    for (let i = 0; i < squares.length; i++) {\n      let splitter = squares[i].toString().split(\" \");\n\n      switch (splitter[0]) {\n        case \"King\":\n          classes.push(new King(parseInt(splitter[1])));\n          break;\n\n        case \"Pawn\":\n          classes.push(new Pawn(parseInt(splitter[1])));\n          break;\n\n        case \"Queen\":\n          classes.push(new Queen(parseInt(splitter[1])));\n          break;\n\n        case \"Bishop\":\n          classes.push(new Bishop(parseInt(splitter[1])));\n          break;\n\n        case \"Knight\":\n          classes.push(new Knight(parseInt(splitter[1])));\n          break;\n\n        case \"Rook\":\n          classes.push(new Rook(parseInt(splitter[1])));\n          break;\n\n        default:\n          classes.push(null);\n      }\n    }\n  }\n\n  return classes;\n}","map":{"version":3,"sources":["/home/panagiotis/Desktop/ds_project/containers/Website/public_html/games/chess/src/components/multiplayer.js"],"names":["openSocket","Bishop","Knight","Queen","Rook","King","Pawn","getArgumenets","url_string","window","location","url","URL","host","hostname","playmanster","searchParams","get","gamemaster","token","args","connect","server","handShake","query","socket","response","setListeners","obj","state","on","message","setState","connectionStatus","roundID","type","myTurn","myColor","board","console","log","classes","stringsToClasses","squares","whiteFallenSoldiers","blackFallenSoldiers","turn","player","status","kingStatus","disconnect","xhr","XMLHttpRequest","onload","e","readyState","respone","JSON","parse","responseText","reconnect","game","master","open","send","port","playmaster","data","i","length","splitter","toString","split","push","parseInt"],"mappings":"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","sourcesContent":["import openSocket from 'socket.io-client';\nimport Bishop from '../pieces/bishop.js';\nimport Knight from '../pieces/knight.js';\nimport Queen from '../pieces/queen.js';\nimport Rook from '../pieces/rook.js';\nimport King from '../pieces/king.js';\nimport Pawn from '../pieces/pawn.js';\n// ==========================================\n// ==> Variables in state <==\n\n//==> host: The domain of the host (localhost)\n//==> gamemaster: the port of gamemaster for client requests\n//==> token: the unique token of the user issued from the Authorization Service\n//==> socket: the socket objet of the client connected to the server\n//==> type: the symbol of the user (X,O or white, black)\n//==> roundID: the ID of the game\n\n//==> connectionStatus: Connection Status\n  // -3 => unauthorized user\n  // -2 => trying to reconnect\n  // -1 => no connection (the client has not connect to the giver Playmaster)\n  //  0 => connected\n  //  1 => wait opponent to connect\n  //  2 => ready to play\n  //  3 => the game is completed\n  //  4 => winner because opponent left\n  //  5 => spectator mode\n\n\n// ==========================================\n// ==> Messages from client to playmaster <==\n\n// 1. Send the new board \n\n// let message = {\n//   roundID : this.state.roundID,\n//   board : squares\n// }\n// this.state.socket.emit('update', message)\n\n\n// 2. Inform the playmaster for the winner, if you are the last to play\n\n// let message = {\n//   roundID : this.state.roundID,\n//   winner: winnerInfo,  //0 for tie, 1 if you won, -1 if you lost\n// }\n// this.state.socket.emit('endgame', message)\n\n// ==========================================\n\n// ===> FOR OTHER GAME CHANGE THE LINE 109 and 133-140\n// ==========================================\n\n\n//Get argument from the URL\nexport function getArgumenets() {\n\tlet url_string = window.location['href'];\n  \tlet url = new URL(url_string);\n\n  \tlet host = url.hostname;\n  \tlet playmanster = url.searchParams.get(\"pm\");\n  \tlet gamemaster = url.searchParams.get(\"gm\");\n  \tlet token = url.searchParams.get(\"token\");\n\n  \tlet args = {\n  \t\t'host': host,\n  \t\t'token': token,\n  \t\t'playmanster' : playmanster,\n  \t\t'gamemaster' : gamemaster,\n  \t};\n\n  \treturn args;\n}\n\n\n//Connect to Playmaster\nexport function connect(server, token){\n\n    let handShake = {\n    \tquery:'token='+token\n    }\n\n    let socket = openSocket(server, handShake)\n\n    let response = {\n    \t'socket': socket,\n    \t'connectionStatus': socket['connected'] ? 0 : -1,\n    }\n\n    return response;\n}\n\n\nexport function setListeners(obj){\n\n  //You connected first, wait for the opponent to connect\n  obj.state.socket.on('wait', message => {\n    obj.setState({\n        connectionStatus: 1,\n        roundID: message['roundID'],\n      })\n  });\n\n\n\n  //Both players are connected. The game can begin\n  obj.state.socket.on('init', message => {\n\n    //Check if the game is new or it is continued from server fault.\n    if (obj.state.type === null){\n      obj.setState({\n        connectionStatus: 2,\n        myTurn: message['turn'],\n        roundID: message['roundID'],\n        myColor: message['turn'] ? 'while' : 'black'   //set your color\n      })\n    }else{\n      obj.setState({\n        connectionStatus: 2,\n        roundID: message['roundID']   //get the new round ID\n      })\n    }\n  });\n\n  //Both players are connected. The game can begin\n  obj.state.socket.on('viewer', board => {\n    console.log('VIWER')\n    var classes = stringsToClasses(board);\n    \n    obj.setState({\n      connectionStatus: 5,\n      squares: classes,\n      myTurn: false\n    })\n  });\n\n\n  //Receive the updated board\n  obj.state.socket.on('board', board => {\n    var classes = stringsToClasses(board[\"board\"]);\n    var whiteFallenSoldiers = stringsToClasses(board[\"whiteFallenSoldiers\"]);\n    var blackFallenSoldiers = stringsToClasses(board[\"blackFallenSoldiers\"]);\n    var turn, player;\n    if (!board['dontChange']){\n      turn = obj.state.turn === 'white'? 'black' : 'white';\n      player = obj.state.player === 1? 2: 1;\n    }else{\n      turn = obj.state.turn;\n      player = obj.state.player;\n    }\n\n      obj.setState({\n        squares: classes,\n        turn: turn,\n        whiteFallenSoldiers: whiteFallenSoldiers,\n        blackFallenSoldiers: blackFallenSoldiers,\n        status: board['status'],\n        kingStatus: board['kingStatus'],\n        player: player,\n        myTurn: true,\n      })\n\n      //Set Game progress\n      if (board['progress']!==0) {\n        obj.setState({\n          connectionStatus: 3,\n        })\n      }\n  }); \n\n\n  //Handler for server disconnection\n  obj.state.socket.on('disconnect', board => {\n\n      //if you never connected or the game is completed, return\n      if (obj.state.connectionStatus < 0 || obj.state.connectionStatus > 2) {\n        return;\n      }\n\n    obj.state.socket.disconnect()\n\n    obj.setState({\n      connectionStatus: 4,\n    })\n    \n    //Create a request to GameMaster\n    var xhr = new XMLHttpRequest()\n\n    xhr.onload = function (e) {\n\n      if (xhr.readyState === 4) {\n\n        //Check if the GameMaster accepted the request\n        if (xhr.connectionStatus === 200) {  \n          let respone = JSON.parse(xhr.responseText);\n          obj.reconnect(respone['playmaster']);\n        }else if(xhr.connectionStatus === 403){\n          obj.setState({\n            connectionStatus: -3,\n          })\n        }\n      }\n    }\n\n    let game = 'chess';\n    let master = obj.state.host + ':' + obj.state.gamemaster\n    let url = 'http://'+master+'?'+'token='+obj.state.token+'&game='+game;\n\n    xhr.open('GET', url);\n    xhr.send();\n  }); \n\n  //The game is over from the server's side\n  obj.state.socket.on('endgame', message => {\n      obj.setState({\n        connectionStatus: 4,\n      })\n      obj.state.socket.disconnect();\n  }); \n\n}\n\n//Establish a new connections\nexport function reconnect(obj, port){\n  console.log('reconnecting...')\n  let playmaster = this.state.host + ':' + port;\n  let token = this.state.token;\n  var data = connect(playmaster,token)\n\n  obj.setState({\n    socket: data['socket'],\n    connectionStatus: data['connectionStatus'],\n  });\n\n  console.log(data['socket']);\n  obj.setListeners();\n}\n\nfunction stringsToClasses(squares){\n  var classes = [];\n\n  if (squares){\n    for (let i=0; i<squares.length; i++){\n      let splitter = squares[i].toString().split(\" \");\n\n      switch(splitter[0]){\n        case \"King\":\n          classes.push(new King(parseInt(splitter[1])));\n          break;\n        case \"Pawn\":\n          classes.push(new Pawn(parseInt(splitter[1])));\n          break;\n        case \"Queen\":\n          classes.push(new Queen(parseInt(splitter[1])));\n          break;\n        case \"Bishop\":\n          classes.push(new Bishop(parseInt(splitter[1])));\n          break;\n        case \"Knight\":\n          classes.push(new Knight(parseInt(splitter[1])));\n          break;\n        case \"Rook\":\n          classes.push(new Rook(parseInt(splitter[1])));\n          break;\n        default:\n          classes.push(null);\n      }\n    }\n  }\n  \n  return classes;\n}"]},"metadata":{},"sourceType":"module"}